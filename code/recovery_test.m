function [x,y,rec_filt,rec_lasso] = recovery_test(params,input_control)
%
% RECOVERY_TEST Test of denoising for a 1-D signal.
%
% Input parameters
%   params : structure with test parameters, with the following fields:
%       *sce [{'RanSin-<k>','CohSin-<k>','Speech','1'-'8'}] : ground truth
%           signal scenario. Here, <k> is the number of harmonics. 
%           Random Sines, Coherent Sines, Speech (file 'mtlb.mat'), or an
%           artificial signal generated by YSIM.
%       snr [double,1] : signal-to-noise ratio (*not* in dBs).
%       lep [{0,1},1] : if 1, use the Lepski-like adaptation procedure.
%       mode [{0-2},0] : filtering windows mode. 0 : pointwise mode,
%           the filter is set up separately for each point. 1 : blockwise
%           mode, signal is divided into blocks, each of the size twice the
%           filter bandwidth, and the blocks are processed separately. 2 :
%           same but the blocks overlap by half.
%       par [{0,1},0] : use parfor. Compatible with neighb = 1 (see below).
%       verb [{0,1},1] : show the progress.
%       neighb [{0,1},1] : boost filter fitting by initializing by solution
%           for the previously processed sample. Compatible with par=1.
%       w [{int > 0},100] : filter bandwidth (not relevant if lepski=1).
%       n [{int > 0},400] : signal length. Must be at least 4*w if mode=0,
%           2*w if mode=1, and 3*w if mode=2.
%   input_control : structure of control parameters for FIT_FILTER. The
%       user may precise just the desired fields, the others are inialized
%       by default (see FIT_FILTER), with rho = 5 and eps = sigma*rho/2
%       where sigma is the noise level defined by <snr>.
%
% Output parameters
%   x : true signal.
%   y : observations.
%   rec_filt : recovery by filtering.
%   rec_lasso : recovery by the Lasso (baseline).
%   
% Example : 3 random sines, Lepski, pointwise, "hot start"
%   params = struct('sce','RanSin-3','lep',1,'mode',0,'neighb',1);
%   [x,y,rec_filt,rec_lasso] = recovery_test(params);
%
% See also : recovery_test2, fit_filter.
%
% Copyright : Dmitry Ostrovsky, 2016.

%% handling params
if ~isfield(params,'sce'), error('Scenario not given.'); end
sce = params.sce;
if ~isfield(params,'snr'), params.snr = 1; end
snr = params.snr;
if ~isfield(params,'lep'), params.lep = 1; end
lep = params.lep;
if ~isfield(params,'mode'), params.mode = 0; end
mode = params.mode;
if ~isfield(params,'par'), params.par = 0; end
par = params.par;
if ~isfield(params,'verb'), params.verb = 1; end
verb = params.verb;
if ~isfield(params,'neighb'), params.neighb = 1; end
neighb = params.neighb;
if ~isfield(params,'w'), params.w = 100; end
w = params.w;
if ~isfield(params,'n'), params.n = 400; end
n = params.n;
%%
t = (0:n-1)';
if length(sce)>=7 ...
        && (strcmp(sce(1:7),'RanSin-') || strcmp(sce(1:7),'CohSin-'))
    k = str2num(sce(8:end));
    if strcmp(sce(1:7),'RanSin-')
        freqs = rand(k,1);
        amps = randn(k,1);
        numfreqs = k;
    else
        spikes = rand(k,1);
        amps = randn(k,1);
        delta = 0.1;
        freqs = [spikes,spikes+delta/n]; % close random spikes
        amps = [amps,amps];
        numfreqs = 2*k;
    end
    x = zeros(n,1);
    for j = 1:numfreqs
        x = x+amps(j)*exp(2*pi*1i*freqs(j)*t')';
    end
    x = real(x);
    sigm = norm(x)/sqrt(n)/snr;
    y = x + sigm*randn(n,1);
elseif strcmp(sce,'Speech') % speech
    speech = open('mtlb.mat');
    x = speech.mtlb(1:n);
    sigm = norm(x)/sqrt(n)/snr;
    y = x + sigm*randn(n,1);
elseif ismember(str2num(sce),1:8) % artificial signal
    [y,x]=ysim(n,snr,str2num(sce));
    sigm = norm(x)/sqrt(n)/snr;
else
    error('Incorrect scenario');
end
%% generate missing control params by default
p = 2; rho = 5; eps = sigm*rho/2;
control = struct('rho',rho,'accuracy','abs','eps',eps);
if nargin == 2 % initialize control params given on input
    fields = fieldnames(input_control);
    for i=1:numel(fields)
        control.(fields{i}) = input_control.(fields{i});
    end
end
control
%%
% in the absolute accuracy mode Lepski starts from w = 2
% in the relative accuracy mode Lepski starts from w = 6
if ~lep
    if mode == 0
        rec_filt = recover_pointwise(y,w,control,par,verb,neighb);
    elseif mode == 1
        rec_filt = recover_blockwise(y,w,control,par,verb,neighb);
    else 
        rec_filt = recover_overblock(y,w,control,par,verb,neighb);
    end
else
    rec_filt = recover_lepski(y,sigm,mode,control,par,verb,neighb);
end
rec_filt = real(rec_filt);

% run Recht's lasso
overf=2;
osize=length(y)*overf;
% penalty "as usual"
lambda=sigm*sqrt(2*log(length(y)))/2;
data=make_rdata(y, osize);
clear control
control.ItrMax=300;
verb = 0;
control.print=verb;
control.Eucl=0;
sol=fncl1mo(data,lambda,control);
rec_lasso=real(raha_oracle(sol.x,data));

figure
param_string = ['sce-' num2str(sce) '_snr-' num2str(snr)...
    '_n-' num2str(n) '_w-' num2str(w) '_p-' num2str(p)...
    '_rho-' num2str(rho) '_lep-' num2str(lep) '_mode-' num2str(mode)];
param_string = strrep(param_string, '.', 'p');
param_string = strrep(param_string, '/', ':');
set(gcf,'name', param_string)
subplot(2,1,1);
if ~strcmp(sce,'Speech'), T = w; else T = n; end
plot(t(1:T),real(x(1:T)),'k-',t(1:T),real(y(1:T)),'b.',...
    t(1:T),real(rec_filt(1:T)),'r-.','Linewidth',2)
legend('Ground Truth', 'Observations', 'Recovery', 'Location','Southwest');
title(['Filtering recovery, ' 'MSE=' num2str(norm(rec_filt(1:T)-x(1:T)))]);
subplot(2,1,2);
plot(t(1:T),real(x(1:T)),'k-',t(1:T),real(y(1:T)),'b.',...
    t(1:T),real(rec_lasso(1:T)),'r-.','Linewidth',2)
legend('Ground Truth', 'Observations', 'Recovery', 'Location','Southwest');
title(['Lasso recovery, ' 'MSE=' num2str(norm(rec_lasso(1:T)-x(1:T)))]);
respath = '../test/rec_test-1d/';
if ~exist(respath, 'dir')
  mkdir(respath);
end
addpath(respath);
savefig(gcf,[respath param_string '.fig']);
set(gcf, 'PaperSize', [11.69 8.27]); % paper size (A4), landscape
% Extend the plot to fill entire paper.
set(gcf, 'PaperPosition', [0 0 11.69 8.27]);
saveas(gcf,[respath param_string '.pdf'],'pdf');
% if ~type
%     soundsc(rec)
% end
end